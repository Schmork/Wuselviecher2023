// Generated by ChatGTP, modified by human

using System;
using System.Collections.Generic;
using System.Linq;

[Serializable]
public class NeuralNetwork : ICloneable
{
    public Layer[] layers;
    public readonly float computationalCost;

    static readonly int memNeurons = 5;
    public int[] memNeuronLayer = new int[memNeurons];
    public int[] memNeuronIndex = new int[memNeurons];

    public NeuralNetwork()
    {
        var numInputs = 3 /*self*/ + memNeurons + 6 /*sensors*/;
        var numHiddenNeurons = numInputs * 5;
        var maxNeuronsPerLayer = numInputs * 3;
        var numOutputs = 2;
        var numConnections = numHiddenNeurons * 3;

        // add input neurons
        List<Layer> layers = new List<Layer>
        {
            new Layer(numInputs, ActivationFunction.Input)
        };
        int numNeurons = numInputs;

        // add hidden neurons
        while (numNeurons < numHiddenNeurons)
        {
            layers.Add(new Layer(UnityEngine.Random.Range(1, maxNeuronsPerLayer)));
            numNeurons += layers[^1].neurons.Length;
        }

        // add outputs
        layers.Add(new Layer(numOutputs));
        layers[^1].neurons[0].function = ActivationFunction.TanH;
        layers[^1].neurons[1].function = ActivationFunction.Sigmoid;

        Dictionary<Neuron, List<Connection>> connections = new Dictionary<Neuron, List<Connection>>();
        foreach (var layer in layers)
        {
            if (layer == layers[0]) continue;
            foreach (var neuron in layer.neurons)
            {
                connections[neuron] = new List<Connection>();
            }
        }

        var conCount = 0;
        while (conCount < numConnections)
        {
            var sourceLayerIndex = UnityEngine.Random.Range(0, layers.Count - 1);
            var sourceLayer = layers[sourceLayerIndex];
            var sourceNeuron = sourceLayer.neurons[UnityEngine.Random.Range(0, sourceLayer.neurons.Length)];
            var targetLayer = layers[UnityEngine.Random.Range(sourceLayerIndex, layers.Count)];
            var targetNeuron = targetLayer.neurons[UnityEngine.Random.Range(0, targetLayer.neurons.Length)];

            var connection = new Connection(sourceNeuron, UnityEngine.Random.Range(-1f, 1f));
            if (!connections[targetNeuron].Contains(connection))
            {
                conCount++;
                connections[targetNeuron].Add(connection);
            }
        }

        foreach (var neuron in connections.Keys)
        {
            var numCons = connections[neuron].Count;
            neuron.sources = new Neuron[numCons];
            neuron.weights = new float[numCons];
            for (int i = 0; i < numCons; i++)
            {
                neuron.sources[i] = connections[neuron][i].source;
                neuron.weights[i] = connections[neuron][i].weight;
            }
        }

        this.layers = layers.ToArray();
        FindAllPaths();
        computationalCost = connections.Count;
    }

    private void FindAllPaths()
    {
        var inputNeurons = layers[0].neurons;
        var outputNeurons = layers[^1].neurons;
        List<Path>[] paths = new List<Path>[outputNeurons.Length];

        for (int i = 0; i < outputNeurons.Length; i++)
        {
            paths[i] = new List<Path>();
            FindAllPathsHelper(paths[i], new Path(new List<Neuron> { outputNeurons[i] }));
        }

        for (int i = 0; i < inputNeurons.Length; i++)
        {
            foreach (List<Path> p in paths)
            {
                foreach (Path path in p)
                {
                    var pathList = path.neurons.ToList();
                    if (pathList.Contains(inputNeurons[i]))
                    {
                        var inputList = inputNeurons[i].paths.ToList();
                        inputList.Add(path);
                        inputNeurons[i].paths = inputList.ToArray();
                    }
                }
            }
        }
    }

    private void FindAllPathsHelper(List<Path> paths, Path path)
    {
        Neuron lastNeuron = path.neurons[^1];

        if (lastNeuron.function == ActivationFunction.Input)
        {
            paths.Add(path);
            return;
        }

        for (int i = 0; i < lastNeuron.sources.Length; i++)
        {

        }

        foreach (Neuron source in lastNeuron.sources)
        {
            if (path.neurons.Contains(source))
            {
                continue;
            }

            FindAllPathsHelper(paths, new Path(path.neurons.Append(source).ToList()));
        }
    }

    public void UpdateInput(int i, float value)
    {
        layers[0].neurons[i].bias = value;
        UnityEngine.Debug.Log("Paths: " + layers[0].neurons[i].paths.Length);
        foreach (var path in layers[0].neurons[i].paths)
        {
            foreach (var neuron in path.neurons)
            {
                neuron.dirty = true;
            }
        }
    }

    public bool Evaluate()
    {
        foreach (var layer in layers)
        {
            layer.Evaluate();
        }
        return true;
    }

    public float[] GetOutput()
    {
        var outputLayer = layers[^1];
        var output = new float[outputLayer.neurons.Length];
        for (int i = 0; i < output.Length; i++)
        {
            output[i] = outputLayer.neurons[i].value;
        }
        return output;
    }

    public object Clone()
    {
        throw new NotImplementedException();
    }
}
